package plasma

import (
	"bytes"
	"crypto/sha256"
	"fmt"
	"github.com/FourthState/plasma-mvp-sidechain/utils"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/rlp"
	"io"
	"math/big"
)

// Transaction represents a spend of inputs. Fields should not be accessed directly
type Transaction struct {
	Inputs  []Input
	Outputs []Output
	Fee     *big.Int
}

type txList struct {
	BlkNum0           [32]byte
	TxIndex0          [32]byte
	OIndex0           [32]byte
	DepositNonce0     [32]byte
	Input0ConfirmSigs [130]byte
	BlkNum1           [32]byte
	TxIndex1          [32]byte
	OIndex1           [32]byte
	DepositNonce1     [32]byte
	Input1ConfirmSigs [130]byte
	NewOwner0         common.Address
	Amount0           [32]byte
	NewOwner1         common.Address
	Amount1           [32]byte
	Fee               [32]byte
}

type rawTx struct {
	Tx   txList
	Sigs [2][65]byte
}

// EncodeRLP satisfies the rlp interface for Transaction
func (tx *Transaction) EncodeRLP(w io.Writer) error {
	t := &rawTx{tx.toTxList(), tx.Sigs()}

	return rlp.Encode(w, t)
}

// DecodeRLP satisfies the rlp interface for Transaction
func (tx *Transaction) DecodeRLP(s *rlp.Stream) error {
	var t rawTx
	if err := s.Decode(&t); err != nil {
		return err
	}

	confirmSigs0 := parseSig(t.Tx.Input0ConfirmSigs)
	confirmSigs1 := parseSig(t.Tx.Input1ConfirmSigs)

	tx.Inputs = append(tx.Inputs, NewInput(NewPosition(big.NewInt(new(big.Int).SetBytes(t.Tx.BlkNum0[:]).Int64()), uint16(new(big.Int).SetBytes(t.Tx.TxIndex0[:]).Int64()), uint8(new(big.Int).SetBytes(t.Tx.OIndex0[:]).Int64()), big.NewInt(new(big.Int).SetBytes(t.Tx.DepositNonce0[:]).Int64())),
		t.Sigs[0], confirmSigs0))
	pos := NewPosition(big.NewInt(new(big.Int).SetBytes(t.Tx.BlkNum1[:]).Int64()), uint16(new(big.Int).SetBytes(t.Tx.TxIndex1[:]).Int64()), uint8(new(big.Int).SetBytes(t.Tx.OIndex1[:]).Int64()), big.NewInt(new(big.Int).SetBytes(t.Tx.DepositNonce1[:]).Int64()))
	if !pos.IsNilPosition() {
		tx.Inputs = append(tx.Inputs, NewInput(pos, t.Sigs[1], confirmSigs1))
	}
	// set signatures if applicable
	tx.Outputs = append(tx.Outputs, NewOutput(t.Tx.NewOwner0, big.NewInt(new(big.Int).SetBytes(t.Tx.Amount0[:]).Int64())))
	if !utils.IsZeroAddress(t.Tx.NewOwner1) {
		tx.Outputs = append(tx.Outputs, NewOutput(t.Tx.NewOwner1, big.NewInt(new(big.Int).SetBytes(t.Tx.Amount1[:]).Int64())))
	}
	tx.Fee = big.NewInt(new(big.Int).SetBytes(t.Tx.Fee[:]).Int64())

	return nil
}

func (tx Transaction) ValidateBasic() error {
	// validate inputs
	for i, input := range tx.Inputs {
		if err := input.ValidateBasic(); err != nil {
			return fmt.Errorf("invalid input with index %d: %s", i, err)
		}
		if input.Position.IsNilPosition() {
			return fmt.Errorf("input position cannot be nil")
		}
	}

	if len(tx.Inputs) > 1 {
		if tx.Inputs[0].Position.String() == tx.Inputs[1].Position.String() {
			return fmt.Errorf("same position cannot be spent twice")
		}
	}

	// validate outputs
	for i, output := range tx.Outputs {
		if err := output.ValidateBasic(); err != nil {
			return fmt.Errorf("invalid output with index %d: %s", i, err)
		}
		if utils.IsZeroAddress(output.Owner) || output.Amount.Sign() == 0 {
			return fmt.Errorf("output with index %d must have a valid address and non-zero amount", i)
		}
	}

	return nil
}

func (tx Transaction) TxBytes() []byte {
	bytes, _ := rlp.EncodeToBytes(&tx)
	return bytes
}

// TxHash returns the bytes the signatures are signed over
func (tx Transaction) TxHash() []byte {
	txList := tx.toTxList()
	bytes, _ := rlp.EncodeToBytes(&txList)
	return crypto.Keccak256(bytes)
}

// MerkleHash returns the bytes that is included in the merkle tree
func (tx Transaction) MerkleHash() []byte {
	hash := sha256.Sum256(tx.TxBytes())
	return hash[:]
}

// Sigs returns the signatures that signed over this transaction
// These signatures were generated by the inputs
func (tx Transaction) Sigs() (sigs [2][65]byte) {
	for i, input := range tx.Inputs {
		sigs[i] = input.Signature
	}
	return sigs
}

func (tx Transaction) String() (str string) {
	for i, input := range tx.Inputs {
		str += fmt.Sprintf("Input %d: %s\n", i, input)
	}
	for i, output := range tx.Outputs {
		str += fmt.Sprintf("Output %d: %s\n", i, output)
	}
	str += fmt.Sprintf("Fee: %s\n", tx.Fee)
	return str
}

/* Helpers */

func (tx Transaction) toTxList() txList {

	// pointer safety if a transaction
	// object was ever created with Transaction{}
	txList := txList{}

	for i, input := range tx.Inputs {
		if input.BlockNum == nil {
			tx.Inputs[i].BlockNum = utils.Big0
		}
		if input.DepositNonce == nil {
			tx.Inputs[i].DepositNonce = utils.Big0
		}
	}

	for i, output := range tx.Outputs {
		if output.Amount == nil {
			tx.Outputs[i].Amount = utils.Big0
		}
	}

	if tx.Fee == nil {
		tx.Fee = utils.Big0
	}

	// fill in txList with values
	// Input 0
	input := tx.Inputs[0]
	if len(input.BlockNum.Bytes()) > 0 {
		copy(txList.BlkNum0[32-len(input.BlockNum.Bytes()):], input.BlockNum.Bytes())
	}
	txList.TxIndex0[31] = byte(input.TxIndex)
	txList.TxIndex0[30] = byte(input.TxIndex >> 8)
	txList.OIndex0[31] = byte(input.OutputIndex)
	if len(input.DepositNonce.Bytes()) > 0 {
		copy(txList.DepositNonce0[32-len(input.DepositNonce.Bytes()):], input.DepositNonce.Bytes())
	}
	switch len(input.ConfirmSignatures) {
	case 1:
		copy(txList.Input0ConfirmSigs[:65], input.ConfirmSignatures[0][:])
	case 2:
		copy(txList.Input0ConfirmSigs[:65], input.ConfirmSignatures[0][:])
		copy(txList.Input0ConfirmSigs[65:], input.ConfirmSignatures[1][:])
	}

	// Input 1
	if len(tx.Inputs) > 1 {
		input = tx.Inputs[1]
		if len(input.BlockNum.Bytes()) > 0 {
			copy(txList.BlkNum1[32-len(input.BlockNum.Bytes()):], input.BlockNum.Bytes())
		}
		txList.TxIndex1[31] = byte(input.TxIndex)
		txList.TxIndex1[30] = byte(input.TxIndex >> 8)
		txList.OIndex1[31] = byte(input.OutputIndex)
		if len(input.DepositNonce.Bytes()) > 0 {
			copy(txList.DepositNonce1[32-len(input.DepositNonce.Bytes()):], input.DepositNonce.Bytes())
		}

		switch len(input.ConfirmSignatures) {
		case 1:
			copy(txList.Input1ConfirmSigs[:65], input.ConfirmSignatures[0][:])
		case 2:
			copy(txList.Input1ConfirmSigs[:65], input.ConfirmSignatures[0][:])
			copy(txList.Input1ConfirmSigs[65:], input.ConfirmSignatures[1][:])
		}
	}
	// Outputs and Fee
	output := tx.Outputs[0]
	txList.NewOwner0 = output.Owner
	if len(output.Amount.Bytes()) > 0 {
		copy(txList.Amount0[32-len(output.Amount.Bytes()):], output.Amount.Bytes())
	}
	if len(tx.Outputs) > 1 {
		output = tx.Outputs[1]
		txList.NewOwner1 = output.Owner
		if len(output.Amount.Bytes()) > 0 {
			copy(txList.Amount1[32-len(output.Amount.Bytes()):], output.Amount.Bytes())
		}
	}
	if len(tx.Fee.Bytes()) > 0 {
		copy(txList.Fee[32-len(tx.Fee.Bytes()):], tx.Fee.Bytes())
	}

	return txList
}

// Helpers
// Convert 130 byte input confirm sigs to 65 byte slices
func parseSig(sig [130]byte) [][65]byte {
	if bytes.Equal(sig[:65], make([]byte, 65)) {
		return [][65]byte{}
	} else if bytes.Equal(sig[65:], make([]byte, 65)) {
		newSig := make([][65]byte, 1)
		copy(newSig[0][:], sig[:65])
		return newSig
	} else {
		newSig := make([][65]byte, 2)
		copy(newSig[0][:], sig[:65])
		copy(newSig[1][:], sig[65:])
		return newSig
	}
}
